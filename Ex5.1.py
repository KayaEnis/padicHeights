################################################################################

# SETUP

E = EllipticCurve([0,0,0, -1351755, 555015942])
P = E(330483/361,63148032/6859)
Q = E(2523,114912) # DQ = (Q)-(-Q) = P
R = E(219,16416) # DR = (R)-(-R) = P
p = 43 # E has split multiplicative reduction at p
prec = 12
K = Qp(p,prec)
EK = E.change_ring(K)
def Log(z): return K(z).log(p_branch=0, change_frac=True) # Iwasawa branch

################################################################################

# I) COMPUTING MAZUR-TATE HEIGHT

def __padic_sigma_square(ET,u,prec):
    q = ET.parameter(prec)
    return (u-1)^2/u*prod([((1-q^n*u)*(1-q^n/u)/(1-q^n)^2)^2 for n in range(1,prec+1)])

ET = E.tate_curve(p) # Tate curve associated to E at p
n = LCM(ET._E.tamagawa_numbers())*(p-1)
S = n*P
cS = denominator(S[0])
q = ET.parameter(prec)
nn = q.valuation()
precp = prec + nn + 2
uS = ET.lift(S, precp)
si = __padic_sigma_square(ET,uS,precp)

MTh = -Log(si*ET._Csquare(precp)/cS)/n^2 # Mazur-Tate height of P

################################################################################

# II) COMPUTING COLEMAN-GROSS HEIGHT

CG_away_from_p = 9*Log(2) # Σ_{q≠p} h_q(DQ,DR)

_.<x> = QQ[]
g = x - 507
gder = g.derivative()
N = 20 # truncation level
_.<t> = PowerSeriesRing(K, 't', default_prec = 4*N)
l = (1-4635873/4*t)^(-1/2)
UU = 0
for i in range(N):
    UU += l.list()[i]*((t^2)^(N-1-i))
U = UU/t^(2*N-1)

# 1) omega_i's
x = t - 507/2
y = g(x).sqrt()
dx_2y = x.derivative()/(2*y)
w = [U*x^i*dx_2y for i in range(2)]
d = [w[i].residue()/(1/t*dx_2y).residue() for i in range(2)]
w = [w[i] - d[i]/t*dx_2y for i in range(2)]
ED = [0,0] + [(t*gder(x)-2*i*g(x))/(t^(i+1))*dx_2y for i in range(1,2*N-1)]
FF = [[] for i in range(2)]
for i in range(2):
    while w[i].valuation() < 0:
        val = w[i].valuation()
        FF[i].append(w[i].list()[0]/ED[-val].list()[0])
        w[i] = w[i] - (w[i].list()[0]/ED[-val].list()[0])*ED[-val]
_.<u,v> = QQ[]
F1 = [0 for i in range(2)]
for i in range(2):
    for j in range(2*N-2):
        F1[i] += FF[i][j]*v/(u^(2*N-2-j))
F1[1] = F1[1] + v

# 2) Let pt = (a,b) and omega = b/(x-a)*dx/y

def base(pt):
    a, b = pt[0], pt[1]
    x = t - 507/2
    y = g(x).sqrt()
    dx_y, dx_2y = x.derivative()/y, x.derivative()/(2*y)
    w = (b/(x-a))*U*dx_y
    d1 = w.residue()/(1/t*dx_2y).residue()
    w = w - d1/t*dx_2y
    ED = [0,0] + [(t*gder(x)-2*i*g(x))/(t^(i+1))*dx_2y for i in range(1,2*N-1)]
    FF = []
    while w.valuation() < 0:
        val = w.valuation()
        FF.append(w.list()[0]/ED[-val].list()[0])
        w = w - (w.list()[0]/ED[-val].list()[0])*ED[-val]
    _.<u,v> = QQ[]
    F = 0
    for i in range(2*N-2):
        F += FF[i]*v/(u^(2*N-2-i))
    d0 = (((b/(x-a))*U*dx_y-F(t,y).derivative()-d1/t*dx_2y)/(1/(x-a)*dx_2y)).list()[0]
    return [F,d0,d1]

# omega = dF + d0/(x-a)*dx/2y + d1/(x+507/2)*dx/2y.

def NC(z):
    Z = z[0] + 507/2
    l = Z*(1-4635873/(4*Z^2)).sqrt()
    return (z[0],z[1]/l)

A = K(-3/2*507).sqrt()
def Int1(i,z1,z2): # integral of omega_i from z1 to z2
    z1 = EK(z1[0],z1[1])
    z2 = EK(z2[0],z2[1])
    exact_part = F1[i](NC(z2)[0]+507/2,NC(z2)[1]) - F1[i](NC(z1)[0]+507/2,NC(z1)[1])
    third_kind_part = d[i]/(2*A)*(Log((NC(z2)[1]-A)/(NC(z2)[1]+A)) - Log((NC(z1)[1]-A)/(NC(z1)[1]+A)))
    return exact_part + third_kind_part

def Int2(pt,z1,z2): # integral of omega from z1 to z2, where omega = b/(x-a)*dx/y, pt = (a,b)
    z1 = EK(z1[0],z1[1])
    z2 = EK(z2[0],z2[1])
    F, d0, d1 = base(pt)
    exact_part = F(NC(z2)[0]+507/2,NC(z2)[1]) - F(NC(z1)[0]+507/2,NC(z1)[1])
    a = pt[0]
    B = K(a-507).sqrt()
    third_kind_part0 = d0/(2*B)*(Log((NC(z2)[1]-B)/(NC(z2)[1]+B)) - Log((NC(z1)[1]-B)/(NC(z1)[1]+B)))
    third_kind_part1 = d1/(2*A)*(Log((NC(z2)[1]-A)/(NC(z2)[1]+A)) - Log((NC(z1)[1]-A)/(NC(z1)[1]+A)))
    return exact_part + third_kind_part0 + third_kind_part1

e2 = E.padic_E2(p,prec)
C = ET._Csquare(prec)
alpha = -e2/(12*C^2) # the unit root subspace W is generated by alpha*omega0 + omega1

# D := (Q)-(-Q), w := y(Q)/(x-x(Q))*dx/y ===> w is a form of the third kind such that Res(w) = D
# psi(w) = c0*omega0 + c1*omega1, wD := w + (c1*alpha - c0)*omega0 ===> wD is the uniqe form 
# of the third kind such that Res(wD) = D and psi(wD) is in W. 
# Easy computation: c0 = int. of omega1 from Q to -Q and c1 = int. of omega0 from -Q to Q.

def h_p(z1,z2): 
    c0 = Int1(1,z1,-z1)
    c1 = Int1(0,-z1,z1)
    return Int2(z1,-z2,z2) + (c1*alpha-c0)*Int1(0,-z2,z2)

CG_at_p = h_p(Q,R) # h_p(DQ,DR)

CGh = CG_at_p + CG_away_from_p # Coleman-Gross height h(DQ,DR)

################################################################################

# III) COMPARING HEIGHTS

CGh - MTh 

################################################################################